# -*- coding: utf-8 -*-
"""final_Major_01.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1RbRpBUBoOmKGsHVwny_jPSwGQEyGJmDB
"""

import os
import cv2
import pandas as pd

# Path to the directory containing your images
image_directory = '/content/Images'

# Create an empty DataFrame to store image information
df = pd.DataFrame(columns=['image_path', 'bounding_box_area'])

# Function to calculate the bounding box area for an image
def calculate_bounding_box_area(image_path):
    image = cv2.imread(image_path)
    height, width, _ = image.shape
    # You would need to obtain the coordinates of the bounding box for your images
    # For this example, let's assume you have the bounding box coordinates as (x, y, w, h)
    x, y, w, h = 10, 20, 100, 80
    area = w * h
    return area

# Iterate through the images in the directory
for filename in os.listdir(image_directory):
    if filename.endswith('.jpg') or filename.endswith('.png'):
        image_path = os.path.join(image_directory, filename)
        bounding_box_area = calculate_bounding_box_area(image_path)
        df = df.append({'image_path': image_path, 'bounding_box_area': bounding_box_area}, ignore_index=True)

# Save the DataFrame to a CSV file
df.to_csv('/content/annotations.csv', index=False)

import cv2
import pandas as pd
from sklearn.model_selection import train_test_split
from sklearn.ensemble import RandomForestClassifier
from sklearn.metrics import accuracy_score, classification_report
import matplotlib.pyplot as plt

# Load the annotated dataset
annotations_df = pd.read_csv('/content/annotations.csv')  # Adjust the file name and path as needed

# Define size category thresholds
small_threshold = 1024
medium_threshold = 9216

# Lists to store image data and labels
image_data = []
labels = []

# Process the dataset
for index, row in annotations_df.iterrows():
    image_path = row['image_path']
    bbox_area = row['bounding_box_area']

    # Load the image
    image = cv2.imread(image_path)

    # Categorize potholes by size
    if bbox_area <= small_threshold:
        category = 'Small Pothole'
    elif small_threshold < bbox_area <= medium_threshold:
        category = 'Medium Pothole'
    else:
        category = 'Large Pothole'

    # Resize the image for analysis
    resized_image = cv2.resize(image, (100, 100))

    # Append image data and labels
    image_data.append(resized_image)
    labels.append(category)

# Split the data into training and testing sets
X_train, X_test, y_train, y_test = train_test_split(image_data, labels, test_size=0.2, random_state=42)

# Train a machine learning model (Random Forest Classifier)
model = RandomForestClassifier(n_estimators=100, random_state=42)
model.fit(X_train, y_train)

# Make predictions on the test data
y_pred = model.predict(X_test)

# Calculate accuracy and generate a classification report
accuracy = accuracy_score(y_test, y_pred)
classification_rep = classification_report(y_test, y_pred)

# Display the results
print(f"Accuracy: {accuracy}")
print(f"Classification Report:\n{classification_rep}")

# Visualize a random test image
rand_idx = 10  # Change this index to visualize different images
plt.imshow(X_test[rand_idx])
plt.title(f"True Category: {y_test[rand_idx]}\nPredicted Category: {y_pred[rand_idx]}")
plt.show()

import cv2
import pandas as pd
from sklearn.model_selection import train_test_split
from sklearn.ensemble import RandomForestClassifier
from sklearn.metrics import accuracy_score, classification_report
import matplotlib.pyplot as plt
import numpy as np

# Load the annotated dataset
annotations_df = pd.read_csv('/content/annotations.csv')  # Adjust the file name and path as needed

# Define size category thresholds
small_threshold = 1024
medium_threshold = 9216

# Lists to store image data and labels
image_data = []
labels = []

# Process the dataset
for index, row in annotations_df.iterrows():
    image_path = row['image_path']
    bbox_area = row['bounding_box_area']

    # Load the image
    image = cv2.imread(image_path)

    # Categorize potholes by size
    if bbox_area <= small_threshold:
        category = 'Small Pothole'
    elif small_threshold < bbox_area <= medium_threshold:
        category = 'Medium Pothole'
    else:
        category = 'Large Pothole'

    # Resize the image to a common size
    resized_image = cv2.resize(image, (100, 100))

    # Flatten the image data
    flattened_image = resized_image.flatten()

    # Append flattened image data and labels
    image_data.append(flattened_image)
    labels.append(category)

# Split the data into training and testing sets
X_train, X_test, y_train, y_test = train_test_split(image_data, labels, test_size=0.2, random_state=42)

# Train a machine learning model (Random Forest Classifier)
model = RandomForestClassifier(n_estimators=100, random_state=42)
model.fit(X_train, y_train)

# Make predictions on the test data
y_pred = model.predict(X_test)

# Calculate accuracy and generate a classification report
accuracy = accuracy_score(y_test, y_pred)
classification_rep = classification_report(y_test, y_pred)

# Display the results
print(f"Accuracy: {accuracy}")
print(f"Classification Report:\n{classification_rep}")

# Visualize a random test image
rand_idx = 10  # Change this index to visualize different images
# Reshape the flattened image for visualization
visualize_image = X_test[rand_idx].reshape(100, 100, 3)
plt.imshow(visualize_image)
plt.title(f"True Category: {y_test[rand_idx]}\nPredicted Category: {y_pred[rand_idx]}")
plt.show()

import cv2

# Load the image
image_path = '/content/new'  # Replace with the path to your image
image = cv2.imread(image_path)

# Convert the image to grayscale for edge detection
gray_image = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)

# Apply Gaussian blur to reduce noise and improve edge detection
blurred_image = cv2.GaussianBlur(gray_image, (5, 5), 0)

# Apply Canny edge detection
edges = cv2.Canny(blurred_image, 50, 150)

# Find contours in the edge-detected image
contours, _ = cv2.findContours(edges, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)

# Initialize a list to store bounding box areas
bounding_box_areas = []

# Loop through the detected contours
for contour in contours:
    # Calculate the area of the bounding box
    x, y, width, height = cv2.boundingRect(contour)
    bounding_box_area = width * height
    bounding_box_areas.append(bounding_box_area)

    # Draw the bounding box on the original image (optional)
    cv2.rectangle(image, (x, y), (x + width, y + height), (0, 255, 0), 2)  # Example color: (0, 255, 0)

# Display the image with bounding boxes (optional)
cv2.imshow('Image with Bounding Boxes', image)
cv2.waitKey(0)
cv2.destroyAllWindows()

# Print the bounding box areas
for i, area in enumerate(bounding_box_areas):
    print(f'Bounding Box {i + 1} Area: {area} square pixels')

import cv2
import os

# Directory where your uploaded images are located
uploaded_images_dir = '/content/Images'

# Directory to save the processed images
processed_images_dir = '/content/new'

# Create the processed images directory if it doesn't exist
os.makedirs(processed_images_dir, exist_ok=True)

# List all files in the uploaded images directory
image_files = [f for f in os.listdir(uploaded_images_dir) if f.endswith('.jpg')]

# Load and process the images, then save them
for image_file in image_files:
    # Construct the full path to the uploaded image
    uploaded_image_path = os.path.join(uploaded_images_dir, image_file)

    # Load the uploaded image using cv2
    image = cv2.imread(uploaded_image_path)

    if image is not None:
       

        # Construct the full path to save the processed image
        processed_image_path = os.path.join(processed_images_dir, image_file)

        # Save the processed image
        cv2.imwrite(processed_image_path, image)
    else:
        print(f"Error loading {image_file}")

print("Images processed and saved in the processed_images directory.")

import cv2
import os

# Directory where your processed images are located
processed_images_dir = '/content/Images'

# Create the output directory for results
results_dir = '/content/result'
os.makedirs(results_dir, exist_ok=True)

# Function to detect potholes and calculate bounding box area
def detect_potholes(image, image_name):
    # Convert the image to grayscale for edge detection
    gray_image = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)

    # Apply Gaussian blur to reduce noise and improve edge detection
    blurred_image = cv2.GaussianBlur(gray_image, (5, 5), 0)

    # Apply Canny edge detection
    edges = cv2.Canny(blurred_image, 50, 150)

    # Find contours in the edge-detected image
    contours, _ = cv2.findContours(edges, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)

    # Initialize a list to store bounding box areas
    bounding_box_areas = []

    # Loop through the detected contours
    for i, contour in enumerate(contours):
        # Calculate the area of the bounding box
        x, y, width, height = cv2.boundingRect(contour)
        bounding_box_area = width * height
        bounding_box_areas.append(bounding_box_area)

        # Optionally, draw and save the bounding box
        cv2.rectangle(image, (x, y), (x + width, y + height), (0, 255, 0), 2)
        result_path = os.path.join(results_dir, f'{image_name}_result_{i}.jpg')
        cv2.imwrite(result_path, image)

    return bounding_box_areas

# List all files in the processed images directory
image_files = [f for f in os.listdir(processed_images_dir) if f.endswith('.jpg')]

# Loop through each processed image
for image_file in image_files:
    # Construct the full path to the processed image
    processed_image_path = os.path.join(processed_images_dir, image_file)

    # Load the processed image using cv2
    image = cv2.imread(processed_image_path)

    if image is not None:
        # Process the image and detect potholes
        image_name = os.path.splitext(image_file)[0]
        bounding_box_areas = detect_potholes(image, image_name)

        # Print the bounding box areas for this image
        for i, area in enumerate(bounding_box_areas):
            print(f'{image_name}_result_{i}: Bounding Box Area - {area} square pixels')

print("Pothole detection and bounding box area calculation completed.")

import os
import cv2
import pandas as pd

# Path to the directory containing your images
image_directory = '/content/result'

# Create an empty DataFrame to store image information
df = pd.DataFrame(columns=['image_path', 'bounding_box_area'])

# Function to calculate the bounding box area for an image
def calculate_bounding_box_area(image_path):
    image = cv2.imread(image_path)
    height, width, _ = image.shape
    # You would need to obtain the coordinates of the bounding box for your images
    # For this example, let's assume you have the bounding box coordinates as (x, y, w, h)
    x, y, w, h = 10, 20, 100, 80
    area = w * h
    return area

# Iterate through the images in the directory
for filename in os.listdir(image_directory):
    if filename.endswith('.jpg') or filename.endswith('.png'):
        image_path = os.path.join(image_directory, filename)
        bounding_box_area = calculate_bounding_box_area(image_path)
        df = df.append({'image_path': image_path, 'bounding_box_area': bounding_box_area}, ignore_index=True)

# Save the DataFrame to a CSV file
df.to_csv('/content/annotations.csv', index=False)